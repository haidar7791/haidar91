// src/BuildingPlacement.js
// ุดุงุดุฉ ุดูุงูุฉ ุชุธูุฑ ููู ุงูุฎุฑูุทุฉ ููุณูุงุญ ูููุณุชุฎุฏู ุจูุถุน ูุจูู ุฌุฏูุฏ
// ูุชู ุนุฑุถ ุดุจุญ ุงููุจููุ ููุชู ุงูุชุญูู ูู ุงูุชุตุงุฏูุงุช ูุจู ุงูุชุฃููุฏ.

import React, { useState, useRef } from "react";
import {
  View,
  StyleSheet,
  Dimensions,
  TouchableOpacity,
  PanResponder,
  Image,
  Text,
} from "react-native";
import { BUILDINGS } from "./BuildingData";
import { MAP_TILES_X,MAP_TILES_Y } from "./MapConfig";
import { placementUtils } from "./placementUtils";

const { width: screenWidth, height: screenHeight } = Dimensions.get("window");

const BuildingPlacement = ({ 
    buildingType, 
    gameState, 
    onConfirmPlacement, 
    onCancelPlacement,
    tileSize, // ๐ ูุฌุจ ุชูุฑูุฑูุง ูู Map.js (TILE_SIZE)
    cameraOffset, // ๐ ูุฌุจ ุชูุฑูุฑูุง ูู Map.js (currentCameraOffset)
}) => {
    // ๐ ุงุณุชุฎุฏุงู ุงูุฎุงุตูุชูู ุงูููุฑุฑุชูู ุจุฏูุงู ูู ุงูุซูุงุจุช ุงููุญููุฉ
    const TILE_SIZE = tileSize || 80;
    const currentCameraOffset = cameraOffset || { x: 0, y: 0 };

    const buildingData = BUILDINGS[buildingType];
    const buildingSize = buildingData.size;

    // ุงูุญุงูุฉ ูุชุชุจุน ูููุน ุงููุจูู ูู ุดุงุดุฉ ุงููุงุชู (ุจุงูุจูุณู)
    const [position, setPosition] = useState({ x: 60, y: 60 });
    // ุงูุญุงูุฉ ูุชุชุจุน ูููุน ุงููุจูู ูู ุดุจูุฉ ุงูุฎุฑูุทุฉ (ุจุงูุจูุงุทุฉ)
    const [gridPosition, setGridPosition] = useState({ x: -1, y: -1 });
    // ุญุงูุฉ ููุชุตุงุฏู
    const [isColliding, setIsColliding] = useState(true);

    const panResponder = useRef(
        PanResponder.create({
            onStartShouldSetPanResponder: () => true,
            onMoveShouldSetPanResponder: () => true,

            onPanResponderMove: (evt, gestureState) => {
                // ุชุญุฏูุซ ุงููููุน ุจุงูุจูุณู
                // ูุชู ุทุฑุญ ูุตู ุญุฌู ุงููุจูู ูุฌุนู ููุทุฉ ุงูุฅูุณุงู ูู ููุชุตู ุงููุจูู
                const newX = gestureState.moveX - (buildingSize.w * TILE_SIZE / 2);
                const newY = gestureState.moveY - (buildingSize.h * TILE_SIZE / 2);
                
                setPosition({ x: newX, y: newY });

                // ุญุณุงุจ ูููุน ุงูุดุจูุฉ (Grid Position)
                // ๐ ุชู ุงุณุชุฎุฏุงู cameraOffset ุงูููุฑุฑ ููุง ูุชุตุญูุญ ุงููููุน
                const gridX = Math.floor((newX - currentCameraOffset.x) / TILE_SIZE);
                const gridY = Math.floor((newY - currentCameraOffset.y) / TILE_SIZE);

                // ุงูุชุญูู ูู ุฃู ุงููููุน ุฏุงุฎู ุญุฏูุฏ ุงูุฎุฑูุทุฉ
                const withinBounds = placementUtils.checkBounds({
                    x: gridX, y: gridY, width: buildingSize.w, height: buildingSize.h
                }, MAP_TILES_X, MAP_TILES_Y);

                if (withinBounds) {
                    // ุงูุชุญูู ูู ุงูุชุตุงุฏู ูุน ุงููุจุงูู ุงูููุฌูุฏุฉ
                    const collision = placementUtils.checkCollision(
                        { x: gridX, y: gridY, width: buildingSize.w, height: buildingSize.h },
                        gameState.buildings,
                        MAP_TILES_X,
                        MAP_TILES_Y,
                        BUILDINGS
                    );
                    
                    setIsColliding(collision);
                    setGridPosition({ x: gridX, y: gridY });
                } else {
                    setIsColliding(true);
                    setGridPosition({ x: -1, y: -1 });
                }
            },
            onPanResponderRelease: () => {
                // ูุง ููุฌุฏ ููุทู ููุงุ ูุชู ุงูุงุนุชูุงุฏ ุนูู ุฒุฑ ุงูุชุฃููุฏ
            },
        })
    ).current;

    const handleConfirm = () => {
        // ูุฌุจ ุฃู ูููู ุฏุงุฎู ุงูุญุฏูุฏ ููุง ููุฌุฏ ุชุตุงุฏู
        if (gridPosition.x !== -1 && !isColliding) {
            onConfirmPlacement(gridPosition.x, gridPosition.y);
        } else {
            // ุฑุณุงูุฉ ุฎุทุฃ ุจุณูุทุฉ ูู ุงููุงุฌูุฉ
            alert("ูุง ูููู ุงูุจูุงุก ููุง! ุงููููุน ูุชุตุงุฏู ุฃู ุฎุงุฑุฌ ุงูุญุฏูุฏ.");
        }
    };

    // ููุท ุดุจุญ ุงููุจูู
    const ghostStyle = {
        left: position.x,
        top: position.y,
        width: buildingSize.w * TILE_SIZE,
        height: buildingSize.h * TILE_SIZE,
        opacity: 0.7,
        position: 'absolute',
        // ุฅุฐุง ูุงู ููุงู ุชุตุงุฏู ุฃู ุฎุงุฑุฌ ุงูุญุฏูุฏุ ุงุณุชุฎุฏู ุงูููู ุงูุฃุญูุฑ
        backgroundColor: isColliding || gridPosition.x === -1 ? 'rgba(255, 0, 0, 0.5)' : 'rgba(0, 255, 0, 0.5)',
        borderRadius: 5,
        borderWidth: 2,
        borderColor: isColliding || gridPosition.x === -1 ? '#FF3333' : '#33FF33',
        zIndex: 999,
        justifyContent: 'center',
        alignItems: 'center',
        
        // ๐ ุงูุชุญููู ุงูุนูุณู ูุฌุนูู ูุณุชููุงู ุฏุงุฎู ุงูุดุจูุฉ ุงููุงุฆูุฉ ุจู 45 ุฏุฑุฌุฉ
        transform: [{ rotate: '-45deg' }],
    };

    return (
        // ๐ ุชุทุจูู ุงููููุงู 45 ุฏุฑุฌุฉ ุนูู ุงูุญุงููุฉ ุงูุดุงููุฉ
        <View style={styles.overlay} {...panResponder.panHandlers}>
            {/* 1. ุดุจุญ ุงููุจูู ุงููุชุญุฑู */}
            {gridPosition.x !== -1 && (
                <View style={ghostStyle}>
                    <Image
                        source={buildingData.levels[1].image} // ุตูุฑุฉ ุงููุณุชูู ุงูุฃูู
                        style={{ width: '100%', height: '100%', opacity: 0.5 }}
                        resizeMode="contain"
                    />
                </View>
            )}

            {/* 2. ุฃุฒุฑุงุฑ ุงูุชุญูู */}
            <View style={styles.controlsContainer}>
                <TouchableOpacity
                    style={[styles.button, styles.cancelButton]}
                    onPress={onCancelPlacement}
                >
                    <Text style={styles.buttonText}>ุฅูุบุงุก</Text>
                </TouchableOpacity>

                <TouchableOpacity
                    style={[styles.button, styles.confirmButton, (isColliding || gridPosition.x === -1) && styles.disabledButton]}
                    onPress={handleConfirm}
                    disabled={isColliding || gridPosition.x === -1}
                >
                    <Text style={styles.buttonText}>ุชุฃููุฏ ุงูุจูุงุก</Text>
                </TouchableOpacity>
            </View>
        </View>
    );
};

const styles = StyleSheet.create({
    overlay: {
        ...StyleSheet.absoluteFillObject,
        backgroundColor: 'rgba(0, 0, 0, 0.2)', // ุฎูููุฉ ุดูุงูุฉ ููููุงู
        zIndex: 500, // ูุธูุฑ ููู ุงูุฎุฑูุทุฉ ูุชุญุช ุดุฑูุท ุงูููุงุฑุฏ
        
        // ๐ ุชุฏููุฑ ุทุจูุฉ ุงูุดุจูุฉ 45 ุฏุฑุฌุฉ (ูุชูุซูู ุงูุดุจูุฉ ุงููุดุทุฉ ุงููุงุฆูุฉ)
        transform: [{ rotate: '45deg' }],
    },
    controlsContainer: {
        position: 'absolute',
        bottom: 50,
        width: '100%',
        flexDirection: 'row',
        justifyContent: 'space-around',
        paddingHorizontal: 20,
        
        // ๐ ุชุญููู ุนูุณู ูุทุจูุฉ ุงูุฃุฒุฑุงุฑ ูุชุจุฏู ูุณุชููุฉ ุนูู ุงูุดุงุดุฉ
        transform: [{ rotate: '-45deg' }],
    },
    button: {
        paddingVertical: 10,
        paddingHorizontal: 20,
        borderRadius: 10,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.3,
        shadowRadius: 5,
        elevation: 8,
    },
    confirmButton: {
        backgroundColor: '#4CAF50', // ุฃุฎุถุฑ
    },
    cancelButton: {
        backgroundColor: '#F44336', // ุฃุญูุฑ
    },
    disabledButton: {
        backgroundColor: '#9E9E9E', // ุฑูุงุฏู
        opacity: 0.6,
    },
    buttonText: {
        color: '#fff',
        fontWeight: 'bold',
        fontSize: 18,
        textAlign: 'center',
    },
});

export default BuildingPlacement;

